#!/bin/bash
set -e -o pipefail
source "$(dirname $0)/functions"

running_id="$(docker ps -q -f name='^rnode$')"
if [[ -n "$running_id" ]]; then
	echo "Node is already running"
	exit 0
fi

if [[ -n "$(docker ps -qa -f name='^rnode$')" ]]; then
	archived_name="rnode.$(date +%s)"
	echo "Existing dead container found, renaming to $archived_name"
	docker rename rnode $archived_name >/dev/null
fi

logcmd docker pull $RD_OPTION_RNODE_DOCKER_IMAGE

mkdir -p /var/lib/rnode /var/lib/rnode/genesis

try_download_file()
{
	local url="$1" file=/var/lib/rnode-static/$2 status
	if [[ -z "$url" ]]; then
		return 0
	fi
	status="$(logcmd curl -fsSL -w '%{http_code}' -z $file -o $file.new "$url")" || true
	if [[ ( -e $file.new || "$status" == 404 ) && -e $file ]]; then
		mv $file "$file.bak$(date -Is)"
	fi
	if [[ -e $file.new ]]; then
		logcmd mv $file.new $file
	fi
}

try_download_file "$RD_OPTION_BONDS_FILE_URL" bonds-20-other.txt
try_download_file "$RD_OPTION_WALLETS_FILE_URL" wallets.txt

i=1
while read pk; do
	echo "$pk $((RD_OPTION_BOND_BASE_AMOUNT + 2**i))"
	: $((i++))
done \
	< /var/lib/rnode-static/validator-public-keys.txt \
	> /var/lib/rnode-static/bonds-10-testnet.txt

sed 's/^[[:blank:]]*//; s/[[:blank:]]*$//; /^$/d' \
	/var/lib/rnode-static/bonds-*.txt >/var/lib/rnode/genesis/bonds.txt

ln -sf /var/lib/rnode-static/wallets.txt /var/lib/rnode/genesis/
ln -sf /var/lib/rnode-static/node.*.pem /var/lib/rnode/

parse_rnode_config

if [[ $rnode_casper_required_signatures -gt 0 && $rnode_server_standalone != true ]]; then
	rnode_casper_genesis_validator=true
fi

eval "$(parse-node-url "$rnode_server_bootstrap" bootstrap_)"
bootstrap_ip="$(dig +short $bootstrap_hostname A | tail -1)"

if [[ -n "$bootstrap_ip" ]]; then
	echo "Bootstrap IP address: $bootstrap_ip"
else
	echo "Failed to get/resolve bootstrap IP" >&2
	exit 1
fi

if ! iptables -L rnode_iblock >/dev/null 2>&1; then
	iptables -N rnode_iblock
fi
if ! iptables -L rnode_oblock >/dev/null 2>&1; then
	iptables -N rnode_oblock
fi
if ! iptables -L rnode_isel >/dev/null 2>&1; then
	iptables -N rnode_isel
	iptables -I INPUT 1 -j rnode_isel
fi
if ! iptables -L rnode_osel >/dev/null 2>&1; then
	iptables -N rnode_osel
	iptables -I OUTPUT 1 -j rnode_osel
fi

iptables -F rnode_iblock
iptables -A rnode_iblock -i lo -j RETURN
iptables -A rnode_iblock -p tcp --dport "$rnode_server_port" -s "$bootstrap_ip" -j RETURN
iptables -A rnode_iblock -p tcp --dport "$rnode_server_port_kademlia" -j REJECT
iptables -A rnode_iblock -p tcp --dport "$rnode_grpc_port_external" -j REJECT

if [[ $rnode_server_standalone != true || $rnode_casper_required_signatures -eq 0 ]]; then
	iptables -A rnode_iblock -p tcp --dport "$rnode_server_port" -j REJECT
fi

iptables -F rnode_oblock
iptables -A rnode_oblock -o lo -j RETURN
iptables -A rnode_oblock -p tcp --dport "$bootstrap_port_kademlia" -j REJECT

iptables -F rnode_isel
iptables -A rnode_isel -j rnode_iblock
iptables -F rnode_osel
iptables -A rnode_osel -j rnode_oblock

network_id="${RD_OPTION_NETWORK_ID:-$rnode_server_network_id}"
echo "Network ID: $network_id"

DIAG_TAG=$(get_current_timestamp).$(sanitize_string "$network_id").$(hostname)
if [[ -n "$RD_OPTION_DUMP_TAG" ]]; then
	DIAG_TAG+=.$(sanitize_string "$RD_OPTION_DUMP_TAG")
fi

mkdir $LOCAL_DIAG_ROOT/$DIAG_TAG
rm -f $DIAG_DIR
ln -s $LOCAL_DIAG_ROOT/$DIAG_TAG $DIAG_DIR

check_diag_directory

if [[ -f /var/lib/rnode-static/local.env ]]; then
	source /var/lib/rnode-static/local.env
fi

logcmd docker run -d \
	--name=rnode \
	--network=host \
	--env-file=/var/lib/rnode-static/environment.docker \
	-v /var/lib/rnode:/var/lib/rnode \
	-v $DIAG_DIR:$DIAG_DIR \
	-v /var/lib/rnode-static:/var/lib/rnode-static:ro \
	-v /usr/lib/x86_64-linux-gnu/libjemalloc.so.2:/opt/libjemalloc.so.2:ro \
	--entrypoint=/opt/docker/bin/rnode \
	$RD_OPTION_RNODE_DOCKER_IMAGE \
	$(get_rnode_launcher_args) \
	-J-Xdebug \
	-J-Xrunjdwp:transport=dt_socket,address=127.0.0.1:8888,server=y,suspend=n \
	-XX:+HeapDumpOnOutOfMemoryError \
	-XX:HeapDumpPath=$DIAG_DIR/heapdump_OOM.hprof \
	-XX:+ExitOnOutOfMemoryError \
	-XX:ErrorFile=$DIAG_DIR/hs_err.log \
	-XX:MaxJavaStackTraceDepth=100000 \
	-XX:NativeMemoryTracking=detail \
	-Dlogback.configurationFile=/var/lib/rnode-static/logback.xml \
	-p docker \
	-c /var/lib/rnode-static/rnode.conf \
	run \
	--network "$network_id" \
	$(get_rnode_run_args) \
	>/dev/null

i=2
sleep_time=5
echo "Waiting $((i*sleep_time))s for RNode to start"

while (( i )); do
	container_id="$(docker ps -q -f name=rnode)"
	if [[ -n "$container_id" ]]; then
		echo "RNode is running"
		nohup docker logs -f $container_id &> $DIAG_DIR/console.log &
		break
	fi

	sleep $sleep_time
	: $((i--))
done

wait_time_left="${RD_OPTION_WAIT_TIME:-600}"
sleep_time=10
echo "Waiting ${wait_time_left}s for approved block"

while (( wait_time_left > 0 )); do
	if [[ -z "$(docker ps -q -f ID=$container_id)" ]]; then
		echo "RNode is not running" >&2
		if [[ -n "$(docker ps -aq -f ID=$container_id)" ]]; then
			echo "----- BEGIN RNODE OUTPUT -----" >&2
			docker logs $container_id >&2 || true
			echo "----- END RNODE OUTPUT -----" >&2
		fi
		exit 1
	fi

	height="$(docker exec $container_id ./bin/rnode show-blocks |\
		sed -n '/^count: /{s///;p;q}')" || true
	if (( height )); then
		echo "Found approved block"
		break
	fi

	sleep $sleep_time
	: $(( wait_time_left -= sleep_time ))
done

if (( wait_time_left <= 0 )); then
	echo "Did not find approved block" >&2
	exit 1
fi

iptables -F rnode_isel
iptables -F rnode_osel

echo Finished
